# Target Function Approximation for Stochastic Circuit Minimization (TFASC)

This project implements the efficient method to find a minimized SC circuit with the approximation error over the target function satisfying the given error bound.

Related papers:
- [1]: Exploring Target Function Approximation for Stochastic Circuit Minimization (Chen and Qian, 2020)

## Important Notes

- Currently this program only includes the Dynamic Approximation (DA) method proposed in [1] as the best one among all the 3 proposed methods. Later on we will add the remaining Perturbation method (PER) and the Degree-Precision Scanning (DPS) method here.
- Since the program requires the EDA tools [ABC](http://people.eecs.berkeley.edu/~alanmi/abc/) and [MVSIS](https://ptolemy.berkeley.edu/projects/embedded/mvsis/), please download the appropriate executable files or compile the source codes in your OS. Make sure to put the executable files of both ABC and MVSIS into `./tool_dir/`. For ABC, also put the script `abc.rc` in this directory.
- This program also calls some PERL scripts for text parsing purpose. Therefore, please make sure PERL is installed on your OS.

## Requirements

- OS: 32-bit Linux (since the executable file of MVSIS used here cannot run in a 64-bit OS currently; 32-bit Ubuntu 16.04 LTS recommended)
- gcc
- g++
- make
- libreadline
- ctags
- PERL
- EDA logic synthesis tools: [ABC](http://people.eecs.berkeley.edu/~alanmi/abc/), [MVSIS](https://ptolemy.berkeley.edu/projects/embedded/mvsis/) executable files

## Input Format

Content in the `input.txt` file:
```
degree n
precision m
feature vector
```
For example, the content of the input file `bm1.2.txt` for `bm1.2` is:
```
4
8
0 254 771 723 215
```
where 4 on the 1st line is for degree `n = 4`, and 8 on the 2nd line is for the precision parameter `m = 8`. On the 3rd line is the input feature vector corresponding to the closest Bernstein polynomial approximating the target function. This input file can be directly generated by the Matlab program in [here](https://github.com/SJTU-ECTL/TFASC/tree/master/Bernstein%20polynomial%20approximation%20by%20Matlab).

## Program Organization
```
| readme.md
| Makefile
|----src
|----tool_dir
|----temp_dir
|----obj
|----input_dir
|     |----demo_benchmarks
|     |----user_benchmarks
|----output_dir
|     |----demo_results
|     |     |----bm1.1
|     |     |----bm1.2
|     |     |----(and so on)
|     |----user_results
|     |     |----test1
|     |     |----(and so on)
```
- src: contains all source files
- `tool_dir`: contains the executable files of ABC and MVSIS together with the `mcnc.genlib` library for standard cell mapping. It also contains the PERL scripts for parsing the ABC/MVSIS results to obtain the reported literal count, delay, and area of the circuit. 
- `temp_dir`: contains temporary files generated during the program is running.
- `obj`: automatically generated by the program.
- `input_dir`: contains two sub-folders, i.e., `demo_benchmarks` and `user_benchmarks`. `demo_benchmarks` contains the input files for all the benchmarks used in our paper [1], while `user_benchmarks` contains the input file(s) provided by the user.
- output_dir: contains two sub-folders, i.e., `demo_results` and `user_results`. `demo_results` contains the output files for all the benchmarks used in our paper [1] in each sub-folder such as `bm1.1/`, `bm1.2/`, etc., while `user_results` contains the sub-folders of the output file(s) corresponding to the input given by the user.
  The output files are:
  - `<bm_name>-solution-summary.txt`: overall summary of the solutions for <bm_name>.
  - `<bm_name>-solution-<num>.pla`: .pla file for the solution with number <num>.
  - `<bm_name>-solution<num>.v`: gate-level Verilog file for the solution with number <num>.
  - `<bm_name>_opt_sol_featureVec.txt`: feature vector for the best solution with minimum area-delay product (ADP) reported by ABC.
  - `bestSol_summary_detailed_ABC.txt`: summary of the best solution with minimum ADP reported by ABC.
  - `bestSol_summary_detailed_ESPRESSO.txt`: summary of the best solution with minimum SOP literal count reported by ESPRESSO.

## Compilation
In the project directory, type `make` to generate the executable `main` file. 

## Usage
There are two modes to run the program, i.e., the `demo` and the `user-defined` modes.
- For the `demo` mode:
  - Step 1: type `make` to compile the program.
  - Step 2: run the program by the command 
    ```
    ./main -demo <target function ID> <test group ID>
    ```
    where `<target function ID>` is a number between 1 and 12 for the following target functions
    ```
    target function ID    target function
    1                     sin(x)
    2                     cos(x)
    3                     exp(-x)
    4                     log(x+1)
    5                     sin(Pi*x)/Pi
    6                     tanh(x)
    7                     tanh(4x)
    8                     x^0.45
    9                     exp(-2x)
    10                    1/(1+exp(-x))
    11                    x^2.2
    12                    0.5*cos(Pi*x)+0.5
    ```
    \<test group ID\> represents for one fo the 4 test groups with different degree n and precision m as
    ```
    test group ID     degree n      precision m
    1                 4             4
    2                 4             8
    3                 6             4
    4                 6             8
    ```
    Example: command `./main -demo 1 2` runs for the benchmark `bm1.2` for the target function `sin(x)` with `n=4` and `m=8`.
    All corresponding input files are provided at `./input_dir/demo_benchmarks/`.
  - Step 3: check the result at `./output_dir/demo_results/bm<target function ID>.<test group ID>/`.

- For the "user-defined" mode:
  - Step 1: before compilation, modify the function `double user_defined_target_function()` in `./src/target_functions.cpp` as the new user-defined target function. 
    For example, if the user-defined target function is `cos(2x)`, then modify this function as
    ```
    double user_defined_target_function(double x){
      return cos(2*x);
    }
    ```
    After this, compile the program again by typing `make`.
  - Step 2: prepare the corresponding input file with the name `<input file name>` in the input directory `./input_dir/user_benchmarks/`. `<input file name>` can be an arbitrary file name. For example, if the input file is `./input_dir/user_benchmarks/user_input.txt`, then `<input file name>` is `user_input.txt`. It should be in the required input format.
  - Step 3: run the program by the command 
  ```
  ./main -user \<input file name\> \<test name\>"
  ```
  where `<test name>` is an arbitrary name given by the user, such as `test1`. Note that both `<input file name>` and `<test name>` do not allow spacing within them.
  For example, the command line
  ```
  ./main -user user_input.txt test1
  ```
  reads in the input file `./input_dir/user_benchmarks/user_input.txt` and generates the result at `./output_dir/user_results/test1/`.
  - Step 4: check the result at `./output_dir/user_results/<test name>/`.
  

  
  
